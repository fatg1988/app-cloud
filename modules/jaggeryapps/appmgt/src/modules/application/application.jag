<%
/*
 * Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *   WSO2 Inc. licenses this file to you under the Apache License,
 *   Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */

include("/jagg/jagg.jag");
include("/jagg/constants.jag");

var log = new Log("module/application/application.jag");
var modManager = jagg.module("manager");
var ApplicationManager = Packages.org.wso2.appcloud.core.ApplicationManager;
var Application = Packages.org.wso2.appcloud.core.dto.Application;
var Version = Packages.org.wso2.appcloud.core.dto.Version;
var KubernetesProvisioningUtils =  Packages.org.wso2.appcloud.provisioning.runtime.Utils.KubernetesProvisioningUtils;
var KubernetesRuntime =  Packages.org.wso2.appcloud.provisioning.runtime.KubernetesRuntimeProvisioningService;
var EventsManager = Packages.org.wso2.appcloud.core.EventsManager;
var Event = Packages.org.wso2.appcloud.core.dto.Event;
var Deployment = Packages.org.wso2.appcloud.core.dto.Deployment;
var Container = Packages.org.wso2.appcloud.core.dto.Container;
var ServiceProxy = Packages.org.wso2.appcloud.core.dto.ContainerServiceProxy;
var CloudUtil = Packages.org.wso2.appcloud.common.util.AppCloudUtil;
var RuntimeProperty = Packages.org.wso2.appcloud.core.dto.RuntimeProperty;
var CarbonUtils = Packages.org.wso2.carbon.utils.CarbonUtils;
var Util = Packages.org.wso2.appcloud.core.Util;
var ResourceQuotaLimit = Packages.org.wso2.appcloud.provisioning.runtime.beans.ResourceQuotaLimit;
var List = Packages.java.util.List;
var Arrays = Packages.java.util.Arrays;
var appTypePropertyConfPath = jagg.getAppTypePropertyConfFilePath();
var parsedObject = parse(appTypePropertyConfPath);
var appTypesProperties = require(parsedObject);
var subscriptionManager = jagg.module("subscription");
var subscription = subscriptionManager.getSubscription();

var APP_LAUNCH_URL_PUBLIC = modManager.getPropertyValue(APP_LAUNCH_URL_PUBLIC);
var APP_LAUNCH_URL_PRIVATE = modManager.getPropertyValue(APP_LAUNCH_URL_PRIVATE);


/**
 * Add an application object
 *
 * @param applicationName name of the application
 * @param versionName revision number of the application
 * @param applicationDescription description of the application
 * @param replicas no of replicas
 * @param uploadedArtifact the uploaded artifact file
 * @param runtimeId runtime id of the application
 */
var addApplication = function (applicationName, versionName, applicationDescription, replicas, runtimeId, appTypeName,
                               runtimePropertiesArray, tagArray, appIcon, uploadedFileName, isNewVersion, conSpecMemory,
                               conSpecCpu, artifactUrl, appCreationMethod, oldHashId, applicationContext, setDefaultVersion,
                               imageId, exposureLevel, sourceLocation) {

    log.info("addApplication : " + stringify({
        applicationName : applicationName,
        versionName : versionName,
        applicationDescription : applicationDescription,
        replicas : replicas,
        runtimeId : runtimeId,
        appTypeName : appTypeName,
        runtimePropertiesArray : runtimePropertiesArray,
        tagArray : tagArray,
        appIcon : appIcon,
        uploadedFileName : uploadedFileName,
        isNewVersion : isNewVersion,
        conSpecMemory : conSpecMemory,
        conSpecCpu : conSpecCpu,
        artifactUrl : artifactUrl,
        appCreationMethod : appCreationMethod,
        oldHashId : oldHashId,
        applicationContext : applicationContext,
        setDefaultVersion : setDefaultVersion,
        imageId : imageId,
        exposureLevel : exposureLevel,
        sourceLocation : sourceLocation
    }));

    var tenantId = modManager.getTenantId();
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);
    if (artifactUrl) { // This is only applicable for url uploaded artifacts
        uploadedFileName = versionHashId + "." + artifactUrl.substring(artifactUrl.lastIndexOf(".") + 1);
    }

    if (sourceLocation || appTypeName == BALLERINA_COMPOSER) {
        sourceLocation = KubernetesProvisioningUtils.getKubernetesValidAppName(applicationName);
    }

    if (isNewVersion == 'true') {
        createAppVersionInDataBase(versionName, runtimeId, runtimePropertiesArray, tagArray, applicationHashId, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation);
    } else {
        createAppInDataBase(applicationName, versionName, applicationDescription, replicas, runtimeId, appTypeName,
                runtimePropertiesArray, tagArray, appIcon, applicationHashId, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation);
    }

    if (sourceLocation && (appCreationMethod == START_FROM_SCRATCH)) {
        // invoke mgtapp and create source location
        jagg.module("mgtapp").createSourceLocation(versionHashId, BALLERINA, sourceLocation, modManager.getPropertyValue(BALLERINA_COMPOSER_SAMPLE));
    }

    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tagName = applicationRuntime.getTag() +"-"+ versionHashId;
    var DockerClient = Packages.org.wso2.appcloud.core.docker.DockerClient;
    var dockerClient = new DockerClient(modManager.getPropertyValue("DockerClientURL"));
    var runtimeProperties = generateRuntimePropsList(runtimePropertiesArray);
    var hostName = constructAppLaunchURL(applicationName, versionName);
    if (applicationContext != null) {
	applicationContext = applicationContext.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
        var versionID = ApplicationManager.getVersionId(versionHashId);
        ApplicationManager.addApplicationContext(versionID, applicationContext);
    }

    if(oldHashId){
        if (log.isDebugEnabled()) {
             log.debug("User has changed the name after uploading the artifact:" + uploadedFileName);
        }
        renameDirectory(oldHashId, versionHashId, uploadedFileName);
    }
    var imageName;
    var readyToTriggerDeployment = true;
    if (appTypeName != CUSTOM && appTypeName != BALLERINA_COMPOSER) { //for custom images uploadedFIleName=null
        var absFileUploadedPath = createDockerFile(applicationName, versionName, appTypeName, runtimeId, uploadedFileName,
                versionHashId, dockerClient, artifactUrl, hostName, appCreationMethod,
                runtimeProperties, conSpecMemory);
        var buildDockerImageStatus = buildDockerImage(applicationName, versionName, runtimeId, absFileUploadedPath, applicationRuntime, tagName,
                versionHashId, dockerClient);
        // eg: registry.docker.appcloud.wso2.com:5000/wso2as
        if (buildDockerImageStatus) {
            imageName = modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL) + "/" + applicationRuntime.getImageName();
            readyToTriggerDeployment = pushDockerImage(applicationName, versionName, imageName, tagName, versionHashId, dockerClient);

        }
    } else { // for custom docker images
        if (appTypeName == BALLERINA_COMPOSER) {
            imageName = modManager.getPropertyValue(BALLERINA_COMPOSER_BASE_IMAGE);
            tagName = modManager.getPropertyValue(BALLERINA_COMPOSER_BASE_IMAGE_TAG);
            log.info("image name : " + imageName + " tag name : " + tagName);
        } else {
            imageName = modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL) + "/" + CUSTOM;
            tagName = imageId;
            log.info("image name : " + imageName + " tag name : " + tagName);
        }
    }

    if(readyToTriggerDeployment) {
        triggerKubernetesDeployment(imageName, runtimeProperties, applicationRuntime, tagName, applicationName,
                                versionName, appTypeName, runtimeId, replicas, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation);
        if (appTypeName != BALLERINA_COMPOSER) {
            putSelectedRevisionToSession(applicationHashId, versionName);
        }
    }
    if (appTypeName != BALLERINA_COMPOSER) {
        if (isNewVersion == 'true') {
            var isSet = parse(setDefaultVersion);
            if (isSet) {
                changeMappedDomain(applicationName, versionName);
            }
        } else {
            setDefaultDomain(applicationName, versionName, applicationHashId);
            ApplicationManager.updateDefaultVersion(applicationHashId, versionName);
        }
    }
};


//Docker build, push and Kubernetes deployment for new artifact obtained via URL
var updateDeployment = function (appType, applicationName, versionName, runtimeId,
                                                runtimePropertiesArray, conSpecMemory, replicas, conSpecCpu,
                                                sourceLocation, applicationHashId, versionHashId, appCreationMethod, sourcePath) {

    log.info("updateDeployment : " + stringify({
        appType : appType,
        applicationName : applicationName,
        versionName : versionName,
        runtimeId : runtimeId,
        runtimePropertiesArray : runtimePropertiesArray,
        conSpecMemory : conSpecMemory,
        replicas : replicas,
        conSpecCpu : conSpecCpu,
        sourceLocation : sourceLocation,
        applicationHashId : applicationHashId,
        versionHashId : versionHashId,
        appCreationMethod : appCreationMethod,
        sourcePath : sourcePath
    }));

    log.info("Triggering docker image creation for new artifact.");
    //Build image with new artifact
    var DockerClient = Packages.org.wso2.appcloud.core.docker.DockerClient;
    var dockerClient = new DockerClient(modManager.getPropertyValue("DockerClientURL"));
    var hostName = constructAppLaunchURL(applicationName, versionName);
    var runtimeProperties = generateRuntimePropsList(runtimePropertiesArray);
    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tagName = applicationRuntime.getTag() +"-"+ versionHashId;
    var exposureLevel = getExposureLevel(applicationName, versionName);
    var fileServerAdminUsername = modManager.getPropertyValue(FILE_SERVER_ADMIN_USERNAME);
    var fileServerAdminPassword = modManager.getPropertyValue(FILE_SERVER_ADMIN_PASSWORD);
    var fileServerUrl = modManager.getPropertyValue(FILE_SERVER_URL);
    var appTypeExtension = sourcePath.substring(sourcePath.length - 3);
    var artifactUrl = "http://" + fileServerAdminUsername + ":" + fileServerAdminPassword + "@" + fileServerUrl + "/" +
            modManager.getTenantDomain(true) + "/" + appType + "/" + applicationName + "/" + sourcePath;
    var uploadedFileName = versionHashId + "." + appTypeExtension;
    var imageName;
    var readyToTriggerDeployment = true;
    if (appType != CUSTOM && appType != BALLERINA_COMPOSER) { //for custom images uploadedFileName=null

        var absFileUploadedPath = createDockerFile(applicationName, versionName, appType, runtimeId,
                uploadedFileName, versionHashId, dockerClient, artifactUrl, hostName, appCreationMethod,
                runtimeProperties, conSpecMemory);
        var buildDockerImageStatus = buildDockerImage(applicationName, versionName, runtimeId, absFileUploadedPath,
                applicationRuntime, tagName, versionHashId, dockerClient);
        if (buildDockerImageStatus) {
            imageName = modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL) + "/" +
                    applicationRuntime.getImageName();
            readyToTriggerDeployment = pushDockerImage(applicationName, versionName, imageName, tagName, versionHashId,
                    dockerClient);
        }
    }
    log.info("Successfully created docker image with new artifact.");
    //Adding deployment pending event
    var msg = "Application deployment successfully triggered in Kubernetes";
    addEvent(KUBE_DEPLOY, EVENT_PENDING, msg, versionHashId);

    if(readyToTriggerDeployment) {
        redeployVersion(applicationName, versionName, versionHashId, appType, exposureLevel, true);
    }
    log.info("Successfully created deployment with new artifact.");
};

var triggerKubernetesDeployment = function(imageName, runtimeProperties, applicationRuntime, tagName, applicationName, versionName, appTypeName, runtimeId, replicas, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation){

    var appHostURL = constructAppLaunchURL(applicationName, versionName);
    var containers = getContainers(imageName, tagName, versionHashId ,versionHashId, runtimeProperties, runtimeId, appHostURL, appTypeName, sourceLocation);
    var deploymentConfig = getDeploymentConfig(containers, versionHashId, replicas);
    if (log.isDebugEnabled()) {
        log.debug("Triggering Kubernetes to deploy version:" + versionHashId);
    }
    deployApplication(applicationName, versionName, appTypeName, deploymentConfig, false, versionHashId, "new", conSpecMemory, conSpecCpu, exposureLevel);
}

var pushDockerImage = function (applicationName, versionName, imageName, tagName, versionHashId, dockerClient){

    //Adding docker image push pending event
    var msg = "Docker image push successfully triggered";
    addEvent(DOCKER_REGISTRY_PUSH, EVENT_PENDING, msg, versionHashId);
    if (log.isDebugEnabled()) {
        log.debug("Start pushing Docker image for version:" + versionHashId);
    }
    try {
        dockerClient.pushDockerImage(imageName, tagName);
    } catch (e) {
        for (var i = 0 ; i < 3 ; i++){
            try{
                log.info("Retrying Docker push retry counter value : " + i);
                dockerClient.pushDockerImage(modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL),applicationRuntime.getImageName(), tagName);
                //Adding docker push success event
                var msg = "Docker image push successfully completed";
                addEvent(DOCKER_REGISTRY_PUSH, EVENT_SUCCEEDED, msg, versionHashId);
                return true;
            } catch (e){
                log.error("Error occurred while pushing image, Hence retrying...");
            }
        }

        var msg = "Error pushing Docker image to remote registry";
        addEvent(DOCKER_REGISTRY_PUSH, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.info("Application creation failed because Docker image push failed and roll back process" +
                 " is started for application : " + applicationName + " with revision : "+versionName);
        deleteVersion(versionHashId, true, false);
        throw e;
    }
    //Adding docker push success event
    var msg = "Docker image push successfully completed";
    addEvent(DOCKER_REGISTRY_PUSH, EVENT_SUCCEEDED, msg, versionHashId);
    return true;
};


var pullDockerImage = function (remoteRepoUrl, imageTag, dockerClient, versionHashId) {
    var msg = "Pulling Docker image from remote repo";
    addEvent(DOCKER_IMAGE_PULL, EVENT_PENDING, msg, versionHashId);
    try {
        dockerClient.pullDockerImage(remoteRepoUrl, imageTag);
        var msg = "Docker image pulled successfully from remote repo";
        addEvent(DOCKER_IMAGE_PULL, EVENT_SUCCEEDED, msg, versionHashId);
    } catch (e) {
        var msg = "Error while pulling Docker image from remote repo";
        addEvent(DOCKER_IMAGE_PULL, EVENT_FAILED, msg, versionHashId);
        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1) {
            log.error("Error while pulling Docker image : " + remoteRepoUrl + " with tag :" + imageTag);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }
        log.error("Pulling Docker image : " + remoteRepoUrl + " with tag : " + imageTag + " failed");
        log.error(e);
        log.info("Application creation failed because Docker image pull failed and roll back process" +
                 " is started for application version hash id : " +versionHashId);
        deleteVersion(versionHashId, true, false);
        throw e;
    }

};

var tagDockerImage = function (oldImageName, oldImageTag, newImageName, newTag, dockerClient, versionHashId) {
    var msg = "Tagging Docker image in registry";
    addEvent(DOCKER_IMAGE_TAG, EVENT_PENDING, msg, versionHashId);
    try {
        dockerClient.tagDockerImage(oldImageName, oldImageTag, newImageName, newTag);
        var msg = "Docker image tagged successfully";
        addEvent(DOCKER_IMAGE_TAG, EVENT_SUCCEEDED, msg, versionHashId);
    } catch (e) {
        var msg = "Tagging Docker image failed";
        addEvent(DOCKER_IMAGE_TAG, EVENT_FAILED, msg, versionHashId);
        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch (e1) {
            log.error("Error while tagging image : " + oldImageName + ":" + " to : " + newImageName + ":" + newTag);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }
        log.error("Tagging Docker image : " + oldImageName + " with tag : " + oldImageName + " to new tag : " + newTag + " failed");
        log.error(e);
        log.info("Application creation failed because Docker image tag failed and roll back process" +
                 " is started.");
        deleteVersion(versionHashId, true, false);
        throw e;
    }
};


var buildDockerImage = function (applicationName, versionName, runtimeId, absFileUploadedPath, applicationRuntime, tagName, versionHashId, dockerClient){

    //Adding docker build pending event
    var msg = "Docker image build successfully triggered";
    addEvent(DOCKER_IMAGE_BUILD, EVENT_PENDING, msg, versionHashId);
    if (log.isDebugEnabled()) {
        log.debug("Start building Docker image for version:" + versionHashId);
    }
    var applicationRuntime = ApplicationManager.getRuntimeById(runtimeId);
    var tenantDockerRegistryUrl = modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL) + "/" + dockerRegTenantSpace;
    var tagName = applicationRuntime.getTag() +"-"+ versionHashId;

    try {

        var dockerRegTenantSpace = modManager.getTenantDomain().replace(".","-");
        dockerClient.buildDockerImage(modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL), applicationRuntime.getImageName(), tagName, absFileUploadedPath);

    } catch (e){

        // Retrying to fix thread interrupted error temporarily. Has to find a proper fix from fabric8
        for (var i = 0 ; i < 3 ; i++){
            try{
                log.info("Retrying Docker build retry counter value : " + i);
                var dockerRegTenantSpace = modManager.getTenantDomain().replace(".","-");
                dockerClient.buildDockerImage(modManager.getPropertyValue(PROPERTY_DOCKER_REGISTRY_URL), applicationRuntime.getImageName(), tagName, absFileUploadedPath);
                //Adding docker build success event
                var msg = "Docker image build successfully built";
                addEvent(DOCKER_IMAGE_BUILD, EVENT_SUCCEEDED, msg, versionHashId);
                return true;
            } catch (e){
                log.error("Error occurred while building image, Hence retrying...");
            }
        }

        var msg = "Error while building Docker file";
        addEvent(DOCKER_IMAGE_BUILD, EVENT_FAILED, msg, versionHashId);

        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }

        log.error(msg);
        log.error(e);
        log.warn("Application creation failed because dokcer image build failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteVersion(versionHashId, true, false);
        throw e;

    }

    //Adding docker build success event
    var msg = "Docker image build successfully built";
    addEvent(DOCKER_IMAGE_BUILD, EVENT_SUCCEEDED, msg, versionHashId);
    return true;
}

var createAppInDataBase = function(applicationName, versionName, applicationDescription, replicas, runtimeId,
                                   appTypeName, runtimePropertiesArray, tagArray, appIcon, applicationHashId, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation){

    //================================= Adding application to Database =========================================
    var application = new Application();
    var version = new Version();
    try {
        if (log.isDebugEnabled()) {
            log.debug("Adding application:" + applicationName + " to database," + " applicationHashId:" + applicationHashId + ", versionHashId:" + versionHashId);
        }
        application.setApplicationName(applicationName);
        application.setHashId(applicationHashId);
        if (applicationDescription != null) {
            applicationDescription = applicationDescription.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
        }
        application.setDescription(applicationDescription);
        application.setApplicationType(appTypeName);
        application.setCloudType(jagg.getSelectedCloud());

        var iconStream = null;
        var iconBlob = null;
        if (appIcon) {
            if (log.isDebugEnabled()) {
                log.debug("Application icon is uploaded by user");
            }
            iconStream = Packages.org.apache.commons.io.IOUtils.toByteArray(appIcon.getStream().getStream());
            iconBlob = new Packages.javax.sql.rowset.serial.SerialBlob(iconStream);
            application.setIcon(iconBlob);
        }
        version.setVersionName(versionName);
        version.setRuntimeId(runtimeId);
        version.setStatus(APPLICATION_CREATED);
        version.setHashId(versionHashId);
        version.setConSpecCpu(conSpecCpu);
        version.setConSpecMemory(conSpecMemory);
        version.setExposureLevel(exposureLevel);
        version.setSourceLocation(sourceLocation);

        if(runtimePropertiesArray.length > 0) {
            var runtimePropertyList = generateRuntimePropsList(runtimePropertiesArray);
            version.setRuntimeProperties(runtimePropertyList);
        }
        if(tagArray.length > 0){
            var tagList = generateTagsList(tagArray);
            version.setTags(tagList);
        }
        var versionList = new java.util.ArrayList();
        versionList.add(version);
        application.setVersions(versionList);
        ApplicationManager.addApplication(application);
    } catch (e){
        var msg = "Error while adding application : " + applicationName + " with version : "+ versionName + " to database";
        log.error(msg);
        log.error(e);
        log.warn("Application creation failed due to initial application metadata persistence failure and roll back process" +
                 " is started for application : "+applicationName+" with version : "+ versionName);
        //Not deleting the uploaded artifact, in the retry option we need previously uploaded artifact to exist.
        throw e;
    }
    return application;
}

var createAppVersionInDataBase = function( versionName, runtimeId, runtimePropertiesArray, tagArray, applicationHashId, versionHashId, conSpecMemory, conSpecCpu, exposureLevel, sourceLocation){
	var version = new Version();
    try {
        if (log.isDebugEnabled()) {
            log.debug("Adding version:" + versionHashId + " to database");
        }
        version.setVersionName(versionName);
        version.setRuntimeId(runtimeId);
        version.setStatus(APPLICATION_CREATED);
        version.setHashId(versionHashId);
        version.setConSpecCpu(conSpecCpu);
        version.setConSpecMemory(conSpecMemory);
        version.setExposureLevel(exposureLevel);
        version.setSourceLocation(sourceLocation);

        if(runtimePropertiesArray.length > 0) {
            var runtimePropertyList = generateRuntimePropsList(runtimePropertiesArray);
            version.setRuntimeProperties(runtimePropertyList);
        }
        if(tagArray.length > 0){
            var tagList = generateTagsList(tagArray);
            version.setTags(tagList);
        }
        ApplicationManager.addApplicationVersion(version, applicationHashId);
    } catch (e){
        var msg = "Error while adding application version : "+ versionName + " to the database";
        log.error(msg);
        log.error(e);
        log.info("Application version creation failed because initial application metadata persistence failed and roll back process" +
                 " is started for application hash id : "+applicationHashId+" with version : "+ versionName);
        throw e;
    }
    return version;
}


var createDockerFile = function (applicationName, versionName, appTypeName, runtimeId, uploadedFileName, versionHashId, dockerClient,
                                 artifactUrl, hostName, appCreationMethod, runtimeProperties, conSpecMemory) {
    var msg = "Docker file creation successfully triggered";
    addEvent(DOCKER_FILE_CREATE, EVENT_PENDING, msg, versionHashId);
    if (log.isDebugEnabled()) {
        log.debug("Start creating Docker file for version:" + versionHashId);
    }
    var absFileUploadedPath;

    try {
        var fileUploadPath = constructFileUploadPath(versionHashId);
        var absFileUploadedPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + fileUploadPath;
        var dockerFilePath = absFileUploadedPath + DOCKER_FILE_NAME;
        if (log.isDebugEnabled()) {
            log.debug("Docker file path for deployment: " + dockerFilePath);
        }
        var dockerTemplateFilePath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + "/" + "dockerfiles";

        var appType = appTypesProperties[appTypeName];
        var isMultiArtifactsSupported = (appType.isMultiArtifactsSupported =='true');

        var uploadArtifactTmpName;
        var artifactNameWithoutExtension;
        if (!isMultiArtifactsSupported) {
            var checkFileExtZIP = isFileExtZIP(uploadedFileName);
            if (checkFileExtZIP && !artifactUrl) {
                var fileName = uploadedFileName.substring(0, uploadedFileName.lastIndexOf("."));
                uploadArtifactTmpName = fileName + FILE_EXTENSTION_ALTER;
            } else {
                uploadArtifactTmpName = uploadedFileName;
            }
            artifactNameWithoutExtension = uploadArtifactTmpName.substring(0, uploadArtifactTmpName.lastIndexOf("."));
        } else {
             uploadArtifactTmpName = uploadedFileName;
        }
        var dockerFilePropertyMap = new java.util.HashMap();
        dockerFilePropertyMap.put("ARTIFACT_NAME", uploadArtifactTmpName);
        dockerFilePropertyMap.put("HOST_NAME", hostName);
        dockerFilePropertyMap.put("ARTIFACT_URL", artifactUrl);
        dockerFilePropertyMap.put("VAL_TOTAL_MEMORY", conSpecMemory);
        dockerFilePropertyMap.put("ARTIFACT_DIR", artifactNameWithoutExtension);

        var mod = jagg.module("application");
        mod.getAppTypeUtil(appTypeName).setDockerEnvironmentVariables(dockerFilePropertyMap);

        var appRuntimeProperties = getRuntimeProperties(runtimeProperties);
        dockerClient.createDockerFile(dockerFilePath, runtimeId, dockerTemplateFilePath, appCreationMethod, dockerFilePropertyMap, appRuntimeProperties);
    } catch(e){
        var msg = "Error while creating Docker file";
        addEvent(DOCKER_FILE_CREATE, EVENT_FAILED, msg, versionHashId);
        try {
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        } catch(e1){
            log.error("Error while updating Application Creation Failed event for application : " + applicationName
                              + " version : " + versionName);
            log.error(e1);
            // not throwing the error, because it will hide the actual exception
        }
        log.error(msg);
        log.error(e);
        log.info("Application creation failed because Docker file creation failed and roll back process" +
                 " is started for application : "+applicationName+" with revision : "+versionName);
        deleteVersion(versionHashId, true, false);
        throw e;
    }
    //Adding docker file create success event
    var msg = "Docker file successfully created for application";
    addEvent(DOCKER_FILE_CREATE, EVENT_SUCCEEDED, msg, versionHashId);
    return absFileUploadedPath;
}

var deployApplication = function(applicationName, versionName, appTypeName, deploymentConfig, isRedeploy, versionHashId, status, conSpecMemoryLimit, conSpecCpuLimit, exposureLevel){

    var conSpecMemory;
    var conSpecCpu;
    //If create application call then pass spec values or else (redeploy) query the database
    if (!(conSpecMemoryLimit && conSpecCpuLimit)) {
       var applicationHashId = Util.getApplicationHashId(applicationName, modManager.getTenantId(true));
       var application = getApplication(applicationHashId);
       if (application.versions) {
            if (application.versions[versionName]) {
                var versionInfo = application.versions[versionName];
                conSpecMemory = versionInfo.conSpecMemory;
                conSpecCpu = versionInfo.conSpecCpu;
            }
        }
    } else {
        conSpecMemory = conSpecMemoryLimit;
        conSpecCpu = conSpecCpuLimit;
    }

    var resourceQuotaLimit = new ResourceQuotaLimit();
    try{
        // increase allocated cpu to fit with memory so that cpu to memory percentage is 1:1.
        if (conSpecCpu < 250) {
            resourceQuotaLimit.setCpuRequest(conSpecCpu * 0.3);
        } else if (conSpecCpu < 350) {
            resourceQuotaLimit.setCpuRequest(conSpecCpu * 0.4);
        } else {
            resourceQuotaLimit.setCpuRequest(conSpecCpu * 0.5);
        }
        resourceQuotaLimit.setCpuLimit(conSpecCpu);
        // allow memory so that guaranteed memory is provided.
        resourceQuotaLimit.setMemoryLimit(conSpecMemory);
        resourceQuotaLimit.setMemoryRequest(conSpecMemory);
    }catch(e){
        var msg = "Error while updating the Resource Quota";
        log.error(msg);
        log.error(e);
    }
    //Adding deployment pending event
    var msg = "Application deployment successfully triggered in Kubernetes";
    addEvent(KUBE_DEPLOY, EVENT_PENDING, msg, versionHashId);
    //Creating basic deployment
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, appTypeName , modManager.getTenantId(true), modManager.getTenantDomain(true), versionHashId, exposureLevel);

    var kubService = new KubernetesRuntime(applicationCtx, resourceQuotaLimit);
    if (log.isDebugEnabled()) {
        log.debug("Deploying application: " + applicationName);
    }
    try{
        kubService.deployApplication(deploymentConfig);
        if(!isRedeploy) {
            persistDeploymentConfig(deploymentConfig, versionHashId);
        }

    } catch(e){
        var msg = "Error while submitting application deployment to Kubernetes";
        if(!isRedeploy) {
            addEvent(KUBE_DEPLOY, EVENT_FAILED, msg, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
        }
        log.error(msg);
        log.error(e);
        log.info("Application deployment failed because Kubernetes deployment was failed and roll back process" +
                 " is started for application: " + applicationName + " with revision: " + versionName);
        if(!isRedeploy) {
            deleteVersion(versionHashId, true, true);
        }
        throw e;
    }
    //Adding deployment success event
    var msg = "Application deployment successful";
    addEvent(KUBE_DEPLOY, EVENT_SUCCEEDED, msg, versionHashId);

    //Checking pod status
    //Adding pod status pending event
    var podStatus = "Pending";
    addEvent(POD_STATUS, EVENT_PENDING, podStatus, versionHashId);
    if(status == "redeploy"){
        java.lang.Thread.sleep(50000);
    }
    counter = 0;
    var timeOut = modManager.getPropertyValue(POD_TIMEOUT);
    while(counter < timeOut){ // Waiting 1 minutes to gets pods up and running
        java.lang.Thread.sleep(1000);
        podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
        counter = counter + 1;
        if (podStatus == "Running") {
            //Adding pod status Running event
            addEvent(POD_STATUS, EVENT_SUCCEEDED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId,APPLICATION_RUNNING);
            break;
        }else if(counter == timeOut){ // if pods doesn't starts withing 5 minutes user redirected to user home
            //Adding pod status error event
            var msg = "Application starting failed";
            var podStatus = KubernetesProvisioningUtils.getPodStatus(applicationCtx);
            addEvent(POD_STATUS, EVENT_FAILED, podStatus, versionHashId);
            ApplicationManager.updateVersionStatus(versionHashId, APPLICATION_ERROR);
            log.info("Application rollback started for application:"+applicationName + " with revision:"+
                     versionName +" because pods are not running even after more than 5 minutes.");
            if(!isRedeploy) {
                deleteVersion(versionHashId, true, true);
            }
        }
    }
    return;
};

var getRestartCounts = function (applicationName, versionName, applicationType){
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = getExposureLevel(applicationName, versionName);
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, applicationType , modManager.getTenantId(true), modManager.getTenantDomain(true), versionHashId, exposureLevel);

    try {
        var kubService = new KubernetesRuntime(applicationCtx);
        var restartCounts = kubService.getPodRestartCounts();
        return restartCounts;
    } catch (e) {
        log.error("Error while getting restart counts for app:" + applicationName);
        log.error(e);
        //throw e;
    }
};

var getReplicaInfo = function (applicationName, versionName, applicationType) {
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = getExposureLevel(applicationName, versionName);
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, applicationType , modManager.getTenantId(true), modManager.getTenantDomain(true), versionHashId, exposureLevel);

    try {
        var kubService = new KubernetesRuntime(applicationCtx);
        var replicaInfo = kubService.getReplicaInfo();
        return replicaInfo;
    } catch (e) {
        log.error("Error while getting replica info for app:" + applicationName);
        log.error(e);
        //throw e;
    }
};

var constructAppLaunchURL = function(applicationName, versionName){
    var appLaunchURL = null;
    var exposureLevel = getExposureLevel(applicationName, versionName);
    applicationName = KubernetesProvisioningUtils.getKubernetesValidAppName(applicationName);
    applicationName = applicationName.toLowerCase();
    var urlPrefix = modManager.getTenantDomain(true)
                            + "-" + applicationName + "-" + versionName;

    if(exposureLevel == "private"){
        appLaunchURL = urlPrefix.replace(/\./g, '-')
                                   +  "." + APP_LAUNCH_URL_PRIVATE;
    } else {
        appLaunchURL = urlPrefix.replace(/\./g, '-')
                               +  "." + APP_LAUNCH_URL_PUBLIC;
    }

    if (log.isDebugEnabled()) {
        log.debug("Application Launch URL: " + appLaunchURL);
    }
    return appLaunchURL;
};

var deleteDeployment = function(versionHashId){
    ApplicationManager.deleteDeployment(versionHashId);
};

var updateApplicationStatus = function(versionHashId, status){
    ApplicationManager.updateVersionStatus(versionHashId, status);
};

var updateVersionExposureLevel = function(newExposureLevel, versionHashId, applicationName, versionName){

    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var appType = getApplication(applicationHashId).applicationType;
    var versionHashId = getVersionHashId(applicationName, versionName);
    var oldExposureLevel = getExposureLevel(applicationName, versionName);
    ApplicationManager.updateVersionExposureLevel(newExposureLevel, versionHashId);
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(applicationName, versionName, appType, tenantId, modManager.getTenantDomain(true), versionHashId, oldExposureLevel);
    var kubernetesRuntimeProvisioningService = new KubernetesRuntime(applicationCtx);

    if (getDefaultVersion(applicationName) == versionName) {
        var hostURL = constructAppLaunchURL(applicationName, versionName);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("htp-"+ versionHashId, newExposureLevel, hostURL);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("hts-"+ versionHashId, newExposureLevel, hostURL);

        var defaultHostURL = constructDefaultAppLaunchURL(applicationName, versionName);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("htp-"+ applicationHashId, newExposureLevel, defaultHostURL);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("hts-"+ applicationHashId, newExposureLevel, defaultHostURL);
    } else {
        var hostURL = constructAppLaunchURL(applicationName, versionName);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("htp-"+ versionHashId, newExposureLevel, hostURL);
        kubernetesRuntimeProvisioningService.changeExposureLevelInServices("hts-"+ versionHashId, newExposureLevel, hostURL);
    }
};

var redeployVersion = function(applicationName, versionName, versionHashId, appTypeName, exposureLevel, isPreviouseEventsValid){
    var isDeleted = deleteApplicationFromKubernetes(versionHashId);
    if (!isPreviouseEventsValid) {
        deleteEventsOfAppVersions(versionHashId);
        var msg = "Successfully triggered stopping container";
        addEvent(STOP_CONTAINERS, EVENT_PENDING, msg, versionHashId);
    } else {
        //Adding deployment pending event
        var msg = "Application deployment successfully triggered in Kubernetes";
        addEvent(KUBE_DEPLOY, EVENT_PENDING, msg, versionHashId);
    }

    if (isDeleted) {
        //updateVersionExposureLevel(exposureLevel, versionHashId, applicationName, versionName);
        updateApplicationStatus(versionHashId, APPLICATION_STOPPED);
        if (!isPreviouseEventsValid) {
            msg = "Successfully completed stopping container";
            addEvent(STOP_CONTAINERS, EVENT_SUCCEEDED, msg, versionHashId);
        }
        redeployApplication(applicationName, versionName, versionHashId, appTypeName, exposureLevel);
        return true;
    } else {
        if (log.isDebugEnabled()) {
            log.debug("Stopping container failed for version:" + versionHashId);
        }
        msg = "Stopping container failed";
        addEvent(STOP_CONTAINERS, EVENT_FAILED, msg, versionHashId);
        return false;
    }
};

var deleteEventsOfAppVersions = function(versionHashId){
    var eventsManager = new EventsManager();
    eventsManager.deleteAllEventsofAppVersion(versionHashId);
    if (log.isDebugEnabled()) {
        log.debug("Deleting events for version:" + versionHashId);
    }
}

var redeployApplication = function(applicationName, versionName, versionHashId, appTypeName, exposureLevel){
    if (log.isDebugEnabled()) {
        log.debug("Redeployment started for version:" + versionHashId);
    }
    var deploymentConfig = buildDeploymentConfigFromDB(versionHashId, applicationName, versionName, appTypeName);
    deployApplication(applicationName, versionName, appTypeName, deploymentConfig, true, versionHashId, "redeploy", null, null, exposureLevel);
    if (getDefaultVersion(applicationName) == versionName) {
        redeployMappedDomain(applicationName, versionName);
    }
};
var persistDeploymentConfig = function(deploymentConfig, versionHashId){

    var containerList = deploymentConfig.getContainers();
    var ctr = containerList.get(0);
    var serviceProxies = ctr.getServiceProxies();
    var deployment = new Deployment();
    deployment.setDeploymentName(deploymentConfig.getDeploymentName());
    log.info("Deployment name:" + deploymentConfig.getDeploymentName());
    deployment.setReplicas(parseInt(deploymentConfig.getReplicas()));
    log.info("Replicas:" + deploymentConfig.getReplicas());

    var proxies = new java.util.HashSet();
    for (var i = 0; i < serviceProxies.size(); i++){
        var svc = serviceProxies.get(i);
        var serviceProxy = new ServiceProxy();
        serviceProxy.setServiceName(svc.getServiceName());
        log.info("Service name:" + svc.getServiceName());
        serviceProxy.setServiceProtocol(svc.getServiceProtocol());
        log.info("Service protocol:" + svc.getServiceProtocol());
        serviceProxy.setServicePort(svc.getServicePort());
        log.info("Service port:" + svc.getServicePort());
        serviceProxy.setServiceBackendPort(svc.getServiceBackendPort());
        log.info("Service Backend Port:" + svc.getServiceBackendPort());

        proxies.add(serviceProxy);
    }

    var container = new Container();
    container.setImageName(ctr.getBaseImageName());
    log.info("Image name:" + ctr.getBaseImageName());
    container.setImageVersion(ctr.getBaseImageVersion());
    log.info("Image version:" + ctr.getBaseImageVersion());

    container.setServiceProxies(proxies);

    var containerSet = new java.util.HashSet();
    containerSet.add(container);
    deployment.setContainers(containerSet);
    ApplicationManager.addDeployment(versionHashId, deployment );
};

var buildDeploymentConfigFromDB = function(versionHashId, applicationName, versionName, appTypeName){
    var deployment = ApplicationManager.getDeployment(versionHashId);

    var deploymentConfig = new Packages.org.wso2.appcloud.provisioning.runtime.beans.DeploymentConfig();
    deploymentConfig.setDeploymentName(deployment.getDeploymentName());
    deploymentConfig.setReplicas(parseInt(deployment.getReplicas()));

    var deploymentContainers = deployment.getContainers();
    var provisioningContainerList = new java.util.ArrayList();
    if(deploymentContainers == null){
        log.error("Cannot find the container information for deployment : " + deployment.getDeploymentName()
                + ", versionHashId : " + versionHashId);
    }
    var containerIterator = deploymentContainers.iterator();
    while(containerIterator.hasNext()){
        var deploymentContainer = containerIterator.next();
        var provisioningContainer = new Packages.org.wso2.appcloud.provisioning.runtime.beans.Container();
        provisioningContainer.setContainerName(versionHashId);
        provisioningContainer.setBaseImageName(deploymentContainer.getImageName());
        provisioningContainer.setBaseImageVersion(deploymentContainer.getImageVersion());

        //Adding runtime properties to k8 container
        var runtimeProperties = deploymentContainer.getRuntimeProperties();
        var envs = getRuntimeProperties(runtimeProperties);
        var sourceLocation = KubernetesProvisioningUtils.getKubernetesValidAppName(applicationName);
        buildEnvironmentVariable(appTypeName, envs, versionHashId, sourceLocation);
        provisioningContainer.setEnvVariables(envs);

        var deploymentProxies = deploymentContainer.getServiceProxies();
        var provisioningProxyList = new java.util.ArrayList();
        var proxyIterator = deploymentProxies.iterator();
        var hostURL = constructAppLaunchURL(applicationName, versionName);

        while(proxyIterator.hasNext()){
            var deploymentProxy = proxyIterator.next();
            var provisioningProxy = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
            provisioningProxy.setServiceName(deploymentProxy.getServiceName());
            if (appTypeName == BALLERINA_COMPOSER) {
                provisioningProxy.setAppHostURL(versionHashId + "." + deploymentProxy.getServiceNamePrefix() + "." + APP_LAUNCH_URL_PUBLIC);
            } else {
                provisioningProxy.setAppHostURL(hostURL);
            }
            provisioningProxy.setServiceName(deploymentProxy.getServiceName());
            provisioningProxy.setServiceProtocol(deploymentProxy.getServiceProtocol());
            provisioningProxy.setServicePort(deploymentProxy.getServicePort());
            provisioningProxy.setServiceBackendPort(parseInt(deploymentProxy.getServiceBackendPort()));
            provisioningProxyList.add(provisioningProxy);
        }
        provisioningContainer.setServiceProxies(provisioningProxyList);

        // set volume mounts
        provisioningContainer.setVolumeMounts(buildVolumeMounts(appTypeName, applicationName));

        provisioningContainerList.add(provisioningContainer);
    }
    deploymentConfig.setContainers(provisioningContainerList);

    return deploymentConfig;

};

function buildVolumeMounts(appTypeName, sourceLocation) {
    var volumnMounts = new java.util.ArrayList();
    if (appTypeName == BALLERINA_COMPOSER) {

        var volumnMount = new Packages.org.wso2.appcloud.provisioning.runtime.beans.VolumeMountInfo();
        volumnMount.setMountPath(modManager.getPropertyValue(BALLERINA_SOURCE_PATH) + "/source");
        volumnMount.setName(VOLUME_MOUNT_NFS);
        volumnMount.setSubPath(sourceLocation);
        volumnMount.setNfsPath(modManager.getPropertyValue(VOLUME_MOUNT_NFS_PATH) + "/" + modManager.getTenantDomain() + "/" + BALLERINA + "/" + sourceLocation);
        volumnMount.setNfsServer(modManager.getPropertyValue(VOLUME_MOUNT_NFS_SERVER));
        volumnMount.setReadOnly(false);

        volumnMounts.add(volumnMount);
    }

    return volumnMounts;
}

function buildEnvironmentVariable(appTypeName, envs, versionHashId, sourceLocation) {

    if (appTypeName == BALLERINA_COMPOSER) {

        envs.put("API_PATH_URL", versionHashId + ".bcb." + APP_LAUNCH_URL_PUBLIC);
        envs.put("LAUNCHER_PATH_URL", versionHashId + ".bcw." + APP_LAUNCH_URL_PUBLIC);
        envs.put("DEBUGGER_PATH_URL", versionHashId + ".bcd." + APP_LAUNCH_URL_PUBLIC);
        envs.put("ROOT_DIR_PATH", modManager.getPropertyValue(BALLERINA_SOURCE_PATH));
        envs.put("TRY_SERVICE_URL", "http://" + versionHashId + ".htp." + APP_LAUNCH_URL_PUBLIC);
        envs.put("LANG_SERVER", versionHashId + ".bls." + APP_LAUNCH_URL_PUBLIC);

        var lastModifiedFile = jagg.module("mgtapp").getLastModifiedFile(sourceLocation);
        if (lastModifiedFile) {
            envs.put("OPEN_FILE", modManager.getPropertyValue(BALLERINA_SOURCE_PATH) + "/source/" + lastModifiedFile);
        }
    }

}
/**
 * Method for getting all the available application types. e.g : war, mss, car
 */
function getContainers(imageName, tag, versionHashId, appServiceName, runtimeProperties, runtimeId, appHostURL, appTypeName, sourceLocation){
    var containerList = new java.util.ArrayList();
    var container = new Packages.org.wso2.appcloud.provisioning.runtime.beans.Container();
    //var appBaseImageName = tenantDockerRegistryUrl + "/" + baseImageName;
    container.setContainerName(versionHashId);
    container.setBaseImageName(imageName);
    container.setBaseImageVersion(tag);

    var envs = getRuntimeProperties(runtimeProperties);
    buildEnvironmentVariable(appTypeName, envs, versionHashId, sourceLocation);
    container.setEnvVariables(envs);
    var serviceProxyList = new java.util.ArrayList();
    var services = ApplicationManager.getTransportsForRuntime(runtimeId);

    for (var i = 0; i < services.length; i++) {
        var serviceProxy = new Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
        var service = services[i];
        serviceProxy.setServiceName(service.getServiceNamePrefix() + "-" + appServiceName);
        if (appTypeName == BALLERINA_COMPOSER) {
            serviceProxy.setAppHostURL(versionHashId + "." + service.getServiceNamePrefix() + "." + APP_LAUNCH_URL_PUBLIC);
        } else {
            serviceProxy.setAppHostURL(appHostURL);
        }
        serviceProxy.setServiceProtocol(service.getServiceProtocol());
        serviceProxy.setServicePort(getIngressPort(service.getServiceName()));
        serviceProxy.setServiceBackendPort(service.getServicePort());
        serviceProxyList.add(serviceProxy);
    }
    container.setServiceProxies(serviceProxyList);

    // volume mounts
    container.setVolumeMounts(buildVolumeMounts(appTypeName, sourceLocation));

    containerList.add(container);
    return containerList;
};


function getRuntimeProperties(runtimeProperties){
    //setting runtime properties to the container
    var envs = new java.util.HashMap();
    if(runtimeProperties) {
        var runtimePropertyIterator = runtimeProperties.iterator();
        while (runtimePropertyIterator.hasNext()) {
            var runtimeProperty = runtimePropertyIterator.next();
            envs.put(runtimeProperty.getPropertyName(), runtimeProperty.getPropertyValue());
        }
    }

    return envs;
}

function getDeploymentConfig(containersList, versionHashId, replicas){

    var deploymentConfig = new Packages.org.wso2.appcloud.provisioning.runtime.beans.DeploymentConfig();
    deploymentConfig.setDeploymentName(versionHashId);
    deploymentConfig.setReplicas(parseInt(replicas));
    deploymentConfig.setContainers(containersList);

    return deploymentConfig;
}

// temp fix to disable esb on certain tiers.
function isAppTypeAllowed() {
    if (subscription) {
        return !(subscription.getPlan() == "integration_cloud_starter");
    }
    return false;
}

/**
 * Method for getting all the available application types e.g : war, mss, car
 */
var getAllAppTypes = function () {
    var appTypeArray = [];
    try {
        var appTypes = ApplicationManager.getAllAppTypesForCloud(jagg.getSelectedCloud());
        for (var i = 0; i < appTypes.length; i++) {
            var appType = appTypes[i];
            var appTypeObject = {};

            appTypeObject.name = appType.appTypeName;
            appTypeObject.description = appType.description;

            if (appTypeObject.name == 'wso2esb') {
                if (isAppTypeAllowed('wso2esb') == true) {
                    appTypeArray.push(appTypeObject);
                }
            } else {
                appTypeArray.push(appTypeObject);
            }

        }
    } catch (e) {
        log.error("Error while getting the list of apptypes");
        log.error(e);
        throw e;
    }

    return appTypeArray;
};

/**
 * Method for getting all the available runtimes e.g : tomcat, wso2as
 * @param appType application type
 */
var getAllRuntimes = function(appType){
    var runtimeArray = [];
    try {
        var runtimes = ApplicationManager.getAllRuntimesForAppType(appType);

        for(var i = 0; i < runtimes.length; i++){
            var runtime = runtimes[i];
            var runtimeObject = {};

            runtimeObject.id = runtime.id;
            runtimeObject.runtimeName = runtime.runtimeName;
            runtimeObject.imageName = runtime.imageName;
            runtimeObject.tag = runtime.tag;
            runtimeObject.description = runtime.description;
            runtimeArray.push(runtimeObject);
        }
    } catch(e){
        log.error("Error while getting the list of runtimes");
        log.error(e);
        throw e;
    }

    return runtimeArray;
}

/**
 * Method for getting the application summery of all the applications per cloud
 */
var getAllApplications = function(){
    var applicationArray = [];
    try {
        var applications = ApplicationManager.getApplicationList(jagg.getSelectedCloud());
        var appTypePropertyConfPath = jagg.getAppTypePropertyConfFilePath();
        var parsedObject = parse(appTypePropertyConfPath);
        var appTypesProperties = require(parsedObject);

        for (var i = 0; i < applications.length; i++) {
            var application = applications[i];
            var applicationObject = {};

            var versions = ApplicationManager.getAllVersionsOfApplication(application.hashId);
            var versionList = [];
            var runningVersionCount = 0;
            for (var j = 0; j < versions.size(); j++) {
                if (versions.get(j).status == APPLICATION_RUNNING && versions.get(j).versionName != BALLERINA_COMPOSER) {
                    var versionObj = {};
                    versionObj.versionName = versions.get(j).versionName;
                    versionObj.status = versions.get(j).status;
                    versionList.push(versionObj);
                    runningVersionCount++;
                }
            }
            applicationObject.applicationName = application.applicationName;
            applicationObject.hashId = application.hashId;
            applicationObject.applicationType = application.applicationType;
            applicationObject.icon = getApplicationIconAsBase64String(application);
            applicationObject.appTypeIcon = appTypesProperties[application.applicationType].icon;
            applicationObject.appTypeTitle = appTypesProperties[application.applicationType].displayName;
            applicationObject.defaultVersion = application.defaultVersion;
            applicationObject.runningVersionCount = runningVersionCount;
            applicationObject.versionList = versionList;
            applicationArray.push(applicationObject);
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }
    return applicationArray;
}

var generateApplicationHashId = function(applicationName){
    var tenantId = modManager.getTenantId(true);
    try {
        return Util.getApplicationHashId(applicationName, tenantId);
    } catch (e){
        var msg = "Error while generating application hash id for application : " + applicationName + " in tenant : "
                + tenantId;
        log.error(msg);
        log.error(e);
        throw e;
    }
}

var getApplicationHashIdByName = function(applicationName){
    try {
        var tenantId = modManager.getTenantId(true);
        var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
        return applicationHashId;
    } catch (e){
        var msg = "Error while getting application hash id for application : " + applicationName;
        log.error(msg);
        log.error(e);
        throw e;
    }
}

var getApplicationNameByHashId = function(applicationHashId){
    try {
        return ApplicationManager.getApplicationNameByHashId(applicationHashId);
    } catch(e){
        var msg = "Error while getting application name for application with hash id : " + applicationHashId;
        log.error(msg);
        log.error(e);
        throw e;
    }
}

var getApplicationHashIdOfMatchingAppName = function(applicationName) {
    try {
        return ApplicationManager.getApplicationHashIdOfMatchingAppName(applicationName);
    } catch(e){
        var msg = "Error while getting application hash id of matching app name: " + applicationName;
        log.error(msg);
        log.error(e);
        throw e;
    }
};

/**
 * Method for getting the application e.g. :- Application {
 *                                              id=1,
 *                                              applicationName="fooApp",
 *                                              revision="1.0.0",
 *                                              runtimeName= "WSO2AS",
 *                                              status = "Running",
 *                                              numberOfReplicas=2
 *                                              description="this is fooApp java application"
 *                                              }
 */
var getApplication = function(applicationHashId){
    var applicationObject = {};
    try {
        var application = ApplicationManager.getApplicationByHashId(applicationHashId);
        applicationObject.applicationName = application.applicationName;
        applicationObject.hashId = application.hashId;
        applicationObject.description = application.description;
        applicationObject.defaultVersion = application.defaultVersion;
        if (application.versions != null) {
            applicationObject.versions = generateVersionList(application.versions, application.applicationName, application.applicationType);
        }
        applicationObject.applicationType = application.applicationType;
        applicationObject.icon = getApplicationIconAsBase64String(application);
        var urlScheme = CloudUtil.getPropertyValue("DeploymentUrlScheme");
        if (isCustomDomainExist(applicationObject.applicationName)) {
            applicationObject.customURL = urlScheme + "://" + getCustomDomain(applicationObject.applicationName);
        } else if (application.defaultVersion != null) {
            applicationObject.defaultURL = urlScheme + "://" + constructDefaultAppLaunchURL(applicationObject.applicationName, application.defaultVersion);
        }
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
    return applicationObject;
}

var generateVersionList = function (versions, applicationName, appType) {
    var versionList = {};
    try {
        for (var i = 0; i < versions.size(); i++) {
            var versionObject = {};
            var version = versions.get(i);

            var versionID = ApplicationManager.getVersionId(version.hashId);
            var deploymentUrl = getDeploymentURL(applicationName, version.versionName, versionID);
            versionObject.deploymentURL = deploymentUrl;
            versionObject.versionName = version.versionName;
            versionObject.hashId = version.hashId;
            versionObject.runtimeId = version.runtimeId;
            versionObject.runtimeName = version.runtimeName;
            versionObject.status = version.status;
            versionObject.conSpecCpu = version.conSpecCpu;
            versionObject.conSpecMemory = version.conSpecMemory;
            versionObject.runtimeProperties = generateRuntimePropsArray(version.runtimeProperties);
            versionObject.tags = generateTagsArray(version.tags);
            versionObject.versionId = versionID;
            versionObject.sourceLocation = version.sourceLocation;
            versionList[version.versionName] = versionObject;
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }
    return versionList;
}

/**
 * Get application icon as a base64 encoded string.
 *
 * @return base64 encoded string, null if icon is null
 */
function getApplicationIconAsBase64String(application) {
    var icon = null;
    if(application.icon){
        icon = Packages.org.apache.commons.codec.binary.Base64.
                encodeBase64String(application.icon.getBytes(1, application.icon.length()));
    }
    return icon;
}

/**
 * Update application icon
 *
 * @param applicationKey application key
 * @param appIcon file object of the appIcon
 */
function changeApplicationIcon(applicationHashId, appIcon){
    if(appIcon){
        var streamHostObject = appIcon.getStream();
        var inputStream = streamHostObject.getStream();
        ApplicationManager.updateApplicationIcon(applicationHashId, inputStream);
    } else {
        log.error("Provided app icon is Empty for application : "+applicationName);
        throw "Provided app icon is Empty";
    }
}

var getEnvVariablesOfVersion = function(versionHashId){

    var evnVariables = [];
    try {
        var envVars = ApplicationManager.getAllRuntimePropertiesOfVersion(versionHashId);
        for (var i = 0; i < envVars.size(); i++) {
            var envObj = {};
            envObj.key = envVars.get(i).propertyName;
            envObj.value = envVars.get(i).propertyValue;
            evnVariables.push(envObj);
        }
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
    return evnVariables;
};

var getTags = function(versionHashId){
    var tags = [];
    try {
        var tagArr = ApplicationManager.getAllTagsOfVersion(versionHashId);
        for (var i = 0; i < tagArr.size(); i++) {
            var tagObj = {};
            tagObj.key = tagArr.get(i).tagName;
            tagObj.value = tagArr.get(i).tagValue;
            tags.push(tagObj);
        }
    } catch(e){
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
    return tags;
};

var updateTag = function (versionHashId, prevKey, newKey, newValue) {
    try {
        ApplicationManager.updateTag(versionHashId, prevKey, newKey, newValue);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var updateRuntimeProperty = function (versionHashId, prevKey, newKey, newValue) {
    try {
        ApplicationManager.updateRuntimeProperty(versionHashId, prevKey, newKey, newValue);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};

var deleteRuntimeProperty = function (versionHashId, key) {
    try {
        ApplicationManager.deleteRuntimeProperty(versionHashId, key);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var deleteTag = function (versionHashId, key) {
    try {
        ApplicationManager.deleteTag(versionHashId, key);
    } catch (e) {
        log.error("Error while getting the application");
        log.error(e);
        throw e;
    }
};
var addRuntimeProperty = function (versionHashId, key, value) {
    try {
        var runtimePropertyList = new java.util.ArrayList();
        var runtimeProperty = new Packages.org.wso2.appcloud.core.dto.RuntimeProperty();
        runtimeProperty.setPropertyName(key);
        runtimeProperty.setPropertyValue(value);
        runtimePropertyList.add(runtimeProperty);
        ApplicationManager.addRuntimeProperties(runtimePropertyList, versionHashId);
    } catch (e) {
        log.error("Error while adding runtime property with Key:" + key);
        log.error(e);
        throw e;
    }
};

var addTag = function (versionHashId, key, value) {
    try {
        var tagList = new java.util.ArrayList();
        var tag = new Packages.org.wso2.appcloud.core.dto.Tag();
        tag.setTagName(key);
        tag.setTagValue(value);
        tagList.add(tag);
        ApplicationManager.addTags(tagList, versionHashId);
    } catch (e) {
        log.error("Error while adding runtime property with Key:" + key);
        log.error(e);
        throw e;
    }
};

var generateTagsList = function (tagListArray) {
    try {
        var size = tagListArray.length;
        var tagList = new java.util.ArrayList();
        for (var i = 0; i < size; i++) {
            var tagJsonObj = tagListArray[i];
            var tag = new Packages.org.wso2.appcloud.core.dto.Tag();
            tag.setTagName(tagJsonObj.key);
            tag.setTagValue(tagJsonObj.value);
            tagList.add(tag);
        }
        return tagList;
    } catch (e) {
        log.error("Error while adding tags : ");
        log.error(tagListArray);
        log.error(e);
        throw e;
    }
};

var generateRuntimePropsList = function (runtimePropsArray) {
    try {
        var size = runtimePropsArray.length;
        var propsList = new java.util.ArrayList();
        for (var i = 0; i < size; i++) {
            var runtimePropJsonObj = runtimePropsArray[i];
            var runtimeProperty = new RuntimeProperty();
            runtimeProperty.setPropertyName(runtimePropJsonObj.key);
            runtimeProperty.setPropertyValue(runtimePropJsonObj.value);
            propsList.add(runtimeProperty);
        }
        return propsList;
    } catch (e) {
        log.error("Error while adding runtime props : ");
        log.error(propsList);
        log.error(e);
        throw e;
    }
};

var generateRuntimePropsArray=function(runtimeList){
    var size = runtimeList.size();
    var runtimePropsArray = [];
    for (var i = 0; i < size; i++) {
        var runtimePropObject = runtimeList.get(i);
        var runtimeProperty = {
            id: runtimePropObject.id,
            propertyName: runtimePropObject.propertyName,
            propertyValue: runtimePropObject.propertyValue,
            description: runtimePropObject.propertyValue
        };
        runtimePropsArray.push(runtimeProperty);
    }
    return runtimePropsArray;
};

var generateTagsArray=function(labelsList){
    var size = labelsList.size();
    var labelsArray = [];
    for (var i = 0; i < size; i++) {
        var labelObject = labelsList.get(i);
        var label = {
            labelName: labelObject.tagName,
            labelValue: labelObject.tagValue,
            description: labelObject.description
        };
        labelsArray.push(label);
    }
    return labelsArray;
};


var getVersionListOfApplication = function(applicationHashId){
    var revisionArray = [];
    try {
        var revisions = ApplicationManager.getVersionListOfApplication(applicationHashId);
        for (var i = 0; i < revisions.size(); i++) {
            if (revisions.get(i).name != BALLERINA_COMPOSER) {
                revisionArray.push(revisions.get(i));
            }
        }
    } catch(e){
        log.error("Error while getting the application list");
        log.error(e);
        throw e;
    }
    return revisionArray;
};

var getDeploymentURL = function (applicationName, versionName, versionID){

    var urlScheme = CloudUtil.getPropertyValue("DeploymentUrlScheme");
    var baseURL = constructAppLaunchURL(applicationName, versionName);
    var applicationLaunchURL = urlScheme + "://" + baseURL;

    if (log.isDebugEnabled()) {
        log.debug("Deployment URL: " + applicationLaunchURL);
    }
    return applicationLaunchURL;
};

var putSelectedRevisionToSession = function(applicationKey, currentRevision) {
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if (!selectedVersions) {
        selectedVersions = {};
    }
    selectedVersions[applicationKey] = currentRevision;
    session.put("SELECTED_REVISIONS", selectedVersions);
};

var getSelectedRevisionFromSession = function(applicationKey) {
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if (selectedVersions && selectedVersions[applicationKey]) {
        return selectedVersions[applicationKey];
    } else {
        return null;
    }
};

var deleteSelectedVersionFromSession = function(applicationKey){
    var selectedVersions = session.get("SELECTED_REVISIONS");
    if (selectedVersions && selectedVersions[applicationKey]) {
        delete selectedVersions[applicationKey];
    }
};

var getVersionHashId = function(applicationName, versionName){
    var tenantId = modManager.getTenantId(true);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId)
    return versionHashId;
}

var getExposureLevel = function(applicationName, versionName){
    var tenantId = modManager.getTenantId();
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = ApplicationManager.getExposureLevel(versionHashId);
    return exposureLevel;
}

var getApplicationCreationEvents = function(applicationName, versionName) {
    var tenantId = modManager.getTenantId(true);
    var versionHashId = Util.getVersionHashId(applicationName, versionName, tenantId);
    var eventsManager = new EventsManager();
    var eventsArray = [];
    try {
        var events = eventsManager.getEventsOfApplication(versionHashId);
        for (var i = 0; i < events.length; i++) {
            var event = events[i];
            var eventObject = {};
            eventObject.name = event.eventName;
            eventObject.status = event.eventStatus;
            eventObject.timestamp = event.timestamp;
            eventObject.description = event.eventDescription;
            eventsArray.push(eventObject);
        }
    } catch(e){
        log.error("Error while getting the application creation event list");
        log.error(e);
        throw e;
    }
    return eventsArray;
};

var uploadExistingArchive = function (uploadedArtifact, appTypeName, applicationName, revision) {
    if(uploadedArtifact){
        var uploadedFileName = uploadedArtifact.getName();
    } else {
        throw "Uploaded artifact does not exist for application:" + applicationName + " version:" + revision;
    }

    var versionHashId = Util.getVersionHashId(applicationName, revision, modManager.getTenantId());
    createDestinationDirsForUploadedApps(versionHashId);
    var fileUploadPath = constructFileUploadPath(versionHashId);

    var uploadApplicationTmpPath;
    var checkFileExtZIP = isFileExtZIP(uploadedFileName);
    //.zip files are auto extracted inside the AS. So if file extension is zip, then extension change to .upload.
    if (checkFileExtZIP) {
        var fileName = uploadedFileName.substring(0, uploadedFileName.lastIndexOf("."));
        uploadApplicationTmpPath = fileUploadPath + fileName + FILE_EXTENSTION_ALTER;
        log.info(uploadApplicationTmpPath);
    } else {
        uploadApplicationTmpPath = fileUploadPath + uploadedFileName;
        log.info(uploadApplicationTmpPath);
    }

    var fileSuccessfullyUploaded = false;
    if (uploadApplicationTmpPath != null) {
        uploadedArtifact.move(uploadApplicationTmpPath);
        var file = new File(uploadApplicationTmpPath);
        var waitCounter = 0;
        var fileUploadTimeout = modManager.getPropertyValue(FILE_UPLOAD_TIMEOUT);
        //Wait until file is completely moved
        while (waitCounter < fileUploadTimeout) {
            if (file.isExists()) {
                fileSuccessfullyUploaded = true;
                log.info("File: " + uploadedFileName + " successfully moved to " + uploadApplicationTmpPath);
                break;
            }
            waitCounter++;
        }
    }
    return fileSuccessfullyUploaded;
};

var renameDirectory = function (oldHashId, newHashId) {
    try {
        var fileUtils = Packages.org.apache.commons.io.FileUtils;
        var oldDirPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + constructFileUploadPath(oldHashId);
        var oldDir = new Packages.java.io.File(oldDirPath);
        var newDirPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + constructFileUploadPath(newHashId);
        var newDir = new Packages.java.io.File(newDirPath);
        fileUtils.moveDirectory(oldDir,newDir);
    } catch (e) {
        log.error("Error while moving directories from : " + oldHashId  + " to : " + newHashId);
        log.error(e);
    }
};

var isFileExtZIP = function (uploadedFileName) {
    var fileExt = uploadedFileName.substr(uploadedFileName.lastIndexOf(".") + 1, uploadedFileName.length);
    if (fileExt == FILE_EXTENTION_ZIP) {
        return true;
    }
    return false;
};

var createDestinationDirsForUploadedApps = function (versionHashId) {
    var fileUtils = Packages.org.apache.commons.io.FileUtils;
    var absFileUploadPath = modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) +
                            constructFileUploadPath(versionHashId);
    var uploadedFilePath = new Packages.java.io.File(absFileUploadPath);
    try {
        fileUtils.forceMkdir(uploadedFilePath);
    } catch (e) {
        log.error("Error while creating the directory : " + absFileUploadPath);
        log.error(e);
    }

};

var downloadFromUrl = function(artifactUrl, applicationName, versionName, apptype){

    var versionHashId = Util.getVersionHashId(applicationName, versionName, modManager.getTenantId());
    createDestinationDirsForUploadedApps(versionHashId);

    var filePath = "";
    var versionDirectoryPath = getVersionDirectoryPath(versionHashId);

    if (apptype == "war"){
        filePath  = versionDirectoryPath + versionHashId + ".war";
    } else if (apptype == "mss") {
        filePath  = versionDirectoryPath + versionHashId + ".jar";
    } else if (apptype == "php") {
        filePath  = versionDirectoryPath + versionHashId + FILE_EXTENSTION_ALTER;
    }
    log.info("apptype: " + apptype);
    try {
        CloudUtil.downloadFromUrl(artifactUrl , filePath);
    } catch (e) {
        log.error("Error while downloading file from the url : " + artifactUrl);
        log.error(e);
        throw e;
    }
};

var addEvent = function(name, status, description, versionHashId) {
    try {
        var eventsManager = new EventsManager();
        var event = new Event();

        event.setEventName(name);
        event.setEventStatus(status);
        event.setTimestamp(new Packages.java.sql.Timestamp(new Date().getTime()));
        event.setEventDescription(description);
        eventsManager.addAppCreationEvent(versionHashId, event);
    } catch (e) {
        log.error("Error while adding app creation event for application with version hash id : "+versionHashId + " with version hash Id :"
                          + versionHashId+" event name:"+name+" ,event status:"+status+" ,event description:"+description);
        log.error(e);
        // not throwing error, because it will affect the application creation process
    }
};

var deleteApplication = function(applicationHashId) {

    try{

        deleteSelectedVersionFromSession(applicationHashId);
        var versionHashIds = ApplicationManager.getVersionHashIdsOfApplication(applicationHashId);

        for (var i = 0; i < versionHashIds.size(); i++) {
            var versionHashId = versionHashIds.get(i);
            deleteApplicationUploadedPath(versionHashId);
            deleteApplicationFromKubernetes(versionHashId);
            deleteEventsOfAppVersions(versionHashId);
        }
        deleteApplicationFromDatabase(applicationHashId);
    } catch(e){
        log.error("Error while deleting application with hash id : " + applicationHashId);
        log.error(e);
    }
};


var deleteVersion = function(versionHashId, isAutoDelete, isDeployed){
    if(!isAutoDelete) {
        deleteApplicationUploadedPath(versionHashId);
    }
    if(isDeployed) {
        deleteApplicationFromKubernetes(versionHashId);
        deleteEventsOfAppVersions(versionHashId);
    }

    var applicationHashId = ApplicationManager.getApplicationHashIdByVersionHashId(versionHashId);
    deleteSelectedVersionFromSession(applicationHashId);
    deleteVersionFromDatabase(versionHashId, applicationHashId);
};

var deleteApplicationUploadedPath = function(versionHashId) {

    var fileUploadPath = getVersionDirectoryPath(versionHashId);
    var fileUtils = Packages.org.apache.commons.io.FileUtils;
    var uploadedFile = new Packages.java.io.File(fileUploadPath);

    if(uploadedFile.exists()){
        fileUtils.deleteDirectory(uploadedFile);
    }
};

var deleteApplicationFromKubernetes = function(versionHashId) {

    try{
        var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(null, null, null, modManager.getTenantId(true),
                                                                               modManager.getTenantDomain(true), versionHashId, null);
        var kubernetesRuntimeProvisioningService = new KubernetesRuntime(applicationCtx);
        return kubernetesRuntimeProvisioningService.deleteDeployment();

    } catch(e){
        log.error("Error while cleaning up the Kubernetes deployment for the version with hash id : " + versionHashId);
        log.error(e);
    }
};

var deleteVersionFromDatabase = function(versionHashId, applicationHashId) {
    try{
        if(ApplicationManager.isSingleVersion(versionHashId)){
            ApplicationManager.deleteApplication(applicationHashId);
        } else {
            ApplicationManager.deleteVersion(versionHashId);
        }
    }catch(e){
        log.error("Error while deleting application version from the database with version hash id : " + versionHashId);
        log.error(e);
    }
};

var deleteApplicationFromDatabase = function (applicationHashId){
    try {
        ApplicationManager.deleteApplication(applicationHashId);
    } catch(e){
        log.error("Error while deleting application from the database with application hash id : " + applicationHashId);
        log.error(e);
    }
};


var getVersionDirectoryPath = function(versionHashId){

    return modManager.getPropertyValue(PROPERTY_APPMGT_DEPLOYMENT_DIR_PATH) + "/" + TMP_UPLOADED_APPLICATIONS_PATH + "/"
                                        + modManager.getTenantDomain() + "/" + versionHashId + "/";
}

var getIngressPort = function(serviceName){

    if(serviceName == "http" || serviceName == "http-alt" || serviceName == "ws"){
        return  80;
    }else if(serviceName == "https" || serviceName == "https-alt"){
        return 443;
    } else{
        return 443;
    }
};

var constructFileUploadPath = function (versionHashId) {
    var fileSeparator = Packages.java.io.File.separator;
    var fileUploadPath = fileSeparator + TMP_UPLOADED_APPLICATIONS_PATH + fileSeparator +
                         modManager.getTenantDomain() + fileSeparator + versionHashId + fileSeparator;
    return fileUploadPath;
};

var getRunningApplicationVersionCount = function(){
    try{
        var tenantId = modManager.getTenantId(true);
        var allTenantRunningApplicationMap = ApplicationManager.getRunningApplicationsOfTenant(tenantId);
        var runningCount = 0;

        if (allTenantRunningApplicationMap && allTenantRunningApplicationMap.entrySet()) {
            var iterator = allTenantRunningApplicationMap.entrySet().iterator();
            while (iterator.hasNext()) {
                var entry = iterator.next();
                var tenantId = entry.getKey();
                var applicationList = entry.getValue();
                for (var i = 0; i < applicationList.size(); i++) {
                    if (applicationList != null) {
                        var app = applicationList.get(i);
                        if (app != null) {
                            var versionName = app.getDefaultVersion();
                            if (versionName != BALLERINA_COMPOSER) {
                                runningCount++;
                            }
                        } else {
                            log.warn("One of the running applications of tenant:" + tenantId + " has a null app.");
                        }
                    } else {
                        log.warn("Number of running application for the tenant:" + tenantId + " is zero.");
                    }
                }
            }
        }

        return runningCount;
    }catch(e){
        log.error("Error while getting application count from the database");
        log.error(e);
        return null;
    }
};

var addCustomDomain = function (applicationName, customDomain) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var kubernetesRuntimeProvisioningService = getKubernetesRuntime(applicationName, applicationHashId, tenantId);
    kubernetesRuntimeProvisioningService.
        updateKubernetesServiceWithLabel(HTTP_SERVICE_PREFIX + applicationHashId, "customDomain", customDomain);
    kubernetesRuntimeProvisioningService.
        updateKubernetesServiceWithLabel(HTTPS_SERVICE_PREFIX + applicationHashId, "customDomain", customDomain);
    ApplicationManager.updateCustomDomain(applicationHashId, customDomain);
};

var getKubernetesRuntime = function(applicationName, applicationHashId, tenantId) {
    var tenantDomain = modManager.getTenantDomain(true);
    var appType = getApplication(applicationHashId).applicationType;
    var versionName = getDefaultVersion(applicationName);
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = getExposureLevel(applicationName, versionName);
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, appType, tenantId, tenantDomain, versionHashId, exposureLevel);
    return new KubernetesRuntime(applicationCtx);
}

var getContainerServiceProxies = function (versionHashId) {
    var containerServiceProxy;
    try {
        containerServiceProxy = ApplicationManager.getContainerServiceProxyByVersion(versionHashId);
    } catch (e) {
        log.error("Error while getting container service proxy with version hash id : " + versionHashId);
        log.error(e);
    }

    return containerServiceProxy;
};

var getCustomDomain = function (applicationName) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    return ApplicationManager.getCustomDomain(applicationHashId);
};

var getDefaultVersion = function (applicationName) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    return ApplicationManager.getDefaultVersion(applicationHashId);
};

var redeployMappedDomain = function (applicationName, versionName) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    deleteService(applicationName, versionName);
    setDefaultDomain(applicationName, versionName, applicationHashId);
    if (isCustomDomainExist(applicationName)) {
        setCustomDomain(applicationName);
    }
}

var changeMappedDomain = function (applicationName, versionName) {
    var tenantId = modManager.getTenantId();
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    deleteService(applicationName, versionName);
    setDefaultDomain(applicationName, versionName, applicationHashId);
    ApplicationManager.updateDefaultVersion(applicationHashId, versionName);
    if (isCustomDomainExist(applicationName)) {
        setCustomDomain(applicationName);
    }
    return applicationHashId;
};

var setCustomDomain = function (applicationName) {
    var hostName = getCustomDomain(applicationName);
    addCustomDomain(applicationName, hostName);
};

var setDefaultDomain = function (applicationName, versionName) {
    var hostName = constructDefaultAppLaunchURL(applicationName, versionName);
    createServiceWithHostName(applicationName, versionName, hostName, true);
};

var isCustomDomainExist = function (applicationName) {
    var customDomain = getCustomDomain(applicationName);

    if (customDomain != null) {
        return true;
    }
    return false;
};

var createServiceWithHostName = function (applicationName, versionName, hostName, isDefaultVersion) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var appType = getApplication(applicationHashId).applicationType;
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = getExposureLevel(applicationName, versionName);

    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, appType, modManager.getTenantId(true), modManager.getTenantDomain(true), versionHashId, exposureLevel);
    var kubernetesRuntimeProvisioningService = new KubernetesRuntime(applicationCtx);

    var containerServiceProxies = getContainerServiceProxies(versionHashId);

    if (containerServiceProxies != null) {
        for (var i = 0; i < containerServiceProxies.size(); i++) {
            var containerServiceProxy = containerServiceProxies.get(i);
            var serviceName = containerServiceProxy.getServiceName();
            var ServiceProxy = Packages.org.wso2.appcloud.provisioning.runtime.beans.ServiceProxy();
            //For custom domain or default domain create service name with ServicePrefix-ApplicationHashId
            if(isDefaultVersion == true){
                var customServiceName = serviceName.substring(0, serviceName.lastIndexOf('-') + 1) + applicationHashId;
            } else {
                var customServiceName = serviceName.substring(0, serviceName.lastIndexOf('-') + 1) + versionHashId;
            }
            ServiceProxy.setServiceName(customServiceName);
            ServiceProxy.setServiceProtocol(containerServiceProxy.getServiceProtocol());
            ServiceProxy.setServicePort(parseInt(containerServiceProxy.getServicePort()));
            ServiceProxy.setServiceBackendPort(parseInt(containerServiceProxy.getServiceBackendPort()));
            ServiceProxy.setAppHostURL(hostName);
            //create a service in k8s
            kubernetesRuntimeProvisioningService.createService(ServiceProxy);
        }
    }
};

var deleteService = function (applicationName, versionName) {
    var tenantId = modManager.getTenantId(true);
    var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
    var appType = getApplication(applicationHashId).applicationType;
    var versionHashId = getVersionHashId(applicationName, versionName);
    var exposureLevel = getExposureLevel(applicationName, versionName);
    var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
            applicationName, versionName, appType, modManager.getTenantId(true), modManager.getTenantDomain(true), versionHashId, exposureLevel);

    var kubernetesRuntimeProvisioningService = new KubernetesRuntime(applicationCtx);
    //delete version specific service from K8s
    var k8sKindService = Packages.org.wso2.appcloud.provisioning.runtime.KubernetesPovisioningConstants.KIND_SERVICE;
    kubernetesRuntimeProvisioningService.deleteK8sKindByName(k8sKindService, "htp-" + applicationHashId);
    kubernetesRuntimeProvisioningService.deleteK8sKindByName(k8sKindService, "hts-" + applicationHashId);
}

var constructDefaultAppLaunchURL = function (applicationName, versionName) {
    var appLaunchURL = null;
    var exposureLevel = getExposureLevel(applicationName, versionName);
    applicationName = KubernetesProvisioningUtils.getKubernetesValidAppName(applicationName);
    applicationName = applicationName.toLowerCase();
    var urlPrefix = modManager.getTenantDomain(true) + "-" + applicationName;

    if(exposureLevel == "private"){
        appLaunchURL = urlPrefix.replace(/\./g, '-')
                + "." + APP_LAUNCH_URL_PRIVATE;
    } else {
        appLaunchURL = urlPrefix.replace(/\./g, '-')
                + "." + APP_LAUNCH_URL_PUBLIC;
    }
    if (log.isDebugEnabled()) {
        log.debug("Default Application Launch URL: " + appLaunchURL);
    }
    return appLaunchURL;
};

var isAplicationVersionExist = function (versionHashId) {
    var applicationExists = false;
    var applicationHashId = ApplicationManager.getApplicationHashIdByVersionHashId(versionHashId);
    if (applicationHashId) {
        applicationExists = true;
    }
    return applicationExists;
};

var getNotAllowedEnvVariables = function () {
    var notAllowedVariables = [];

        var notAllowedVariableString = modManager.getPropertyValue(NOT_ALLOWED_ENV_VARIABLES);
        var notAllowedVariableList = notAllowedVariableString.split("\\s*,\\s*");

        for (var i = 0; i < notAllowedVariableList.length; i++ ){
            notAllowedVariables.push(notAllowedVariableList[i].toLowerCase());
        }

        return notAllowedVariables;
};

var getApplicationRevisionStatus = function(applicationKey, selectedRevision) {
    var selectedRevisionStatus = null;
    try {
        var versions = getVersionsOfApplication(applicationKey);
        for (var i = 0; i < versions.length; i++) {
            if (versions[i].key == selectedRevision) {
                selectedRevisionStatus = versions[i].value;
                break;
            }
        }
    } catch (e) {
        log.error("Error while getting the versions for application " + applicationKey + " and version " + selectedRevision);
        log.error(e);
        throw e;
    }
    return selectedRevisionStatus;
};

var getVersionsOfApplication = function (applicationKey) {
    var applicationVersions = [];
    try {
        var versions = ApplicationManager.getAllVersionsOfApplication(applicationKey);
        for (var i = 0; i < versions.size(); i++) {
            var versionObj = {};
            versionObj.key = versions.get(i).versionName;
            versionObj.value = versions.get(i).status;
            applicationVersions.push(versionObj);
        }
    } catch (e) {
        throw e;
    }
    return applicationVersions;
};

var getRuntimePropertyMap = function (runtimePropertyArray) {
    var runtimePropertyList = generateRuntimePropsList(runtimePropertyArray);
    return getRuntimeProperties(runtimePropertyList);
};

var getAllowedContainerSpecificationsForRuntime = function (runtimeId) {
    try {
        var containerSpecifications = ApplicationManager.getAllowedContainerSpecificationsForRuntime(runtimeId);
        var allowedContainerSpecifications = { "data": []};
        for (var i = 0; i < containerSpecifications.length; i++) {
            allowedContainerSpecifications.data.push(
                    {
                        "conSpecName": containerSpecifications[i].conSpecName,
                        "costPerHour": containerSpecifications[i].costPerHour,
                        "cpu": containerSpecifications[i].cpu,
                        "id": containerSpecifications[i].id,
                        "memory": containerSpecifications[i].memory
                    }
            );
        }
        return allowedContainerSpecifications;
    } catch (e) {
        log.error("Error while getting allowed container specifications for runtime with ID: " + runtimeId);
        log.error(e);
        throw e;
    }
};

/**
  * Get the application summary with tags of all the tagged applications
  */
 var getTaggedApplicationsList = function () {
     var applicationArray = [];
     try {
         var applications = ApplicationManager.getTaggedApplicationsList(jagg.getSelectedCloud());
         var appTypePropertyConfPath = jagg.getAppTypePropertyConfFilePath();
         var parsedObject = parse(appTypePropertyConfPath);
         var appTypesProperties = require(parsedObject);

         for (var i = 0; i < applications.length; i++) {
             var application = applications[i];
             var applicationObject = {};
             var tagArray = [];
             applicationObject.applicationName = application.applicationName;
             applicationObject.hashId = application.hashId;
             applicationObject.applicationType = application.applicationType;
             applicationObject.icon = getApplicationIconAsBase64String(application);
             applicationObject.appTypeIcon = appTypesProperties[application.applicationType].icon;
             applicationObject.appTypeTitle = appTypesProperties[application.applicationType].displayName;

             if(application.versions != null && application.versions.get(0) != null & application.versions.get(0).tags != null){
                 for (var j = 0; j < application.versions.get(0).tags.size(); j++) {
                     var tagObject = {};
                     tagObject.tagKey = application.versions.get(0).tags.get(j).tagName;
                     tagObject.tagValue = application.versions.get(0).tags.get(j).tagValue;
                     tagArray.push(tagObject);
                 }
             }
             applicationObject.tagArray = tagArray;
             applicationArray.push(applicationObject);
         }
     } catch (e) {
         log.error("Error while getting the tagged application list");
         log.error(e);
         throw e;
     }
     return applicationArray;
 }

var isEnvironmentVariableExist = function(versionKey, envVariableKey) {
    return ApplicationManager.isEnvironmentVariableExist(versionKey, envVariableKey);
}

var isTagExist = function(versionKey, tagKey) {
    return ApplicationManager.isTagExist(versionKey, tagKey);
}

var isVersionExist = function(applicationName, versionName) {
    return ApplicationManager.isVersionExist(applicationName, versionName);
}

/**
 * Method to get custom domain details (application name, default domain URL and custom domain URL) for all applications
 * of logged in user
 *
 * @returns {Array}
 */
var getCustomDomainDetailsForTenant = function() {
    var applicationLaunchBaseURL = APP_LAUNCH_URL_PUBLIC;
    var applicationDetailsList = ApplicationManager.getCustomDomainDetailsForTenant();
    var urlPrefix = modManager.getTenantDomain(true) + "-";
    var customDomainDetails = [];
    for (var i = 0; i < applicationDetailsList.length; i++) {
        var applicationDetail = applicationDetailsList[i];
        var customDomainDetail = {};
        customDomainDetail.appName = applicationDetail.applicationName;
        customDomainDetail.defaultDomainURL = urlPrefix.replace(/\./g, '-')  +
                applicationDetail.applicationName.toLowerCase() + "." + applicationLaunchBaseURL;
        customDomainDetail.customDomainURL = applicationDetail.customDomain;
        customDomainDetails.push(customDomainDetail);
    }
    return customDomainDetails;
}

var isCustomDomainAvailable = function (customDomain) {
    return ApplicationManager.isCustomDomainAvailable(customDomain);
}

var scaleDeployment = function (applicationName, versionName, replicaCount) {
    try {
        var tenantId = modManager.getTenantId(true);
        var applicationHashId = Util.getApplicationHashId(applicationName, tenantId);
        var appType = getApplication(applicationHashId).applicationType;
        var versionHashId = getVersionHashId(applicationName, versionName);
        var applicationCtx = KubernetesProvisioningUtils.getApplicationContext(
                    applicationName, versionName, appType, tenantId, modManager.getTenantDomain(true),
                    versionHashId, null);
        var kubernetesRuntimeProvisioningService = new KubernetesRuntime(applicationCtx);

        kubernetesRuntimeProvisioningService.scaleDeployment(versionHashId, replicaCount);
        ApplicationManager.updateReplicationCountForDeployment(replicaCount, versionHashId);
    } catch (e) {
        log.error("Error while scaling application: " + applicationName + " version: " + versionName);
        log.error(e);
        throw e;
    }
};

var getReplicaCountForVersion = function (applicationName, versionName) {
    try {
        var versionHashId = getVersionHashId(applicationName, versionName);
        return ApplicationManager.getReplicaCountForVersion(versionHashId);
    } catch (e) {
         log.error("Error while getting replicaCount for application: " + applicationName + " version: " + versionName);
         log.error(e);
         throw e;
    }
};

var isApplicationNameValid = function (applicationName) {
    var appHashId = getApplicationHashIdByName(applicationName);
    return getApplication(appHashId).hashId != null;
};

var isApplicationKeyValid = function (applicationKey) {
    return getApplication(applicationKey).hashId == applicationKey;
};

var getVersionByHashId = function (versionHashId) {
    var versionObject = {};
    try {
        var version = ApplicationManager.getVersionByHashId(versionHashId);
        if (version != null) {
            versionObject.hashId = version.hashId;
            versionObject.status = version.status;
            versionObject.conSpecCpu = version.conSpecCpu;
            versionObject.conSpecMemory = version.conSpecMemory;
        }
    } catch (e) {
        log.error("Error while getting version info by hash id : " + versionHashId);
        log.error(e);
        throw e;
    }
    return versionObject;
};

%>
